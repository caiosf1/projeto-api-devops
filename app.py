# ===================================================================================
# üì¶ IMPORTA√á√ïES E EXPLICA√á√ïES
# ===================================================================================

# FLASK - Framework web minimalista para Python
# Documenta√ß√£o: https://flask.palletsprojects.com/
from flask import Flask, jsonify, request

# Flask ‚Üí Classe principal para criar aplica√ß√£o web
# jsonify ‚Üí Converte dicion√°rio Python em JSON (formato para APIs)
# request ‚Üí Objeto global com dados da requisi√ß√£o HTTP (body, headers, etc)

# SQLALCHEMY - ORM (Object-Relational Mapping)
# Traduz classes Python em tabelas SQL
# Exemplo: Usuario() vira linha na tabela "usuario"
from flask_sqlalchemy import SQLAlchemy

# MIGRATE - Gerencia mudan√ßas no banco de dados
# Cria arquivos de "migra√ß√£o" quando voc√™ muda models
# Ex: adiciona coluna "prioridade" ‚Üí cria migration ‚Üí aplica no banco
from flask_migrate import Migrate

# PYDANTIC - Valida√ß√£o de dados
# Valida JSON enviado pelo usu√°rio
# Ex: descricao m√≠nimo 3 caracteres, prioridade enum [baixa, media, alta]
from pydantic import ValidationError

# BCRYPT - Criptografia de senhas
# NUNCA salve senha em texto plano!
# bcrypt.hash("senha123") ‚Üí "$2b$12$NaXz..." (hash seguro)
from flask_bcrypt import Bcrypt

# JWT - JSON Web Tokens (autentica√ß√£o stateless)
# Ap√≥s login, retorna token: "eyJhbGci..." 
# Cliente envia token no header: Authorization: Bearer eyJhbGci...
# Servidor valida token e identifica usu√°rio
from flask_jwt_extended import (
    JWTManager,           # Gerenciador JWT
    create_access_token,  # Cria token ap√≥s login
    jwt_required,         # Decorator: rota precisa de token
    get_jwt_identity      # Extrai email do token
)

# FLASK-RESTX - Documenta√ß√£o Swagger autom√°tica
# Cria interface /docs com todos endpoints
# Resource ‚Üí Classe que representa endpoint REST
# fields ‚Üí Define tipos de dados (string, int, bool)
from flask_restx import Api, Resource, fields

# CORS - Cross-Origin Resource Sharing
# Permite frontend (localhost:8000) acessar backend (localhost:5000)
# Sem CORS ‚Üí navegador bloqueia requisi√ß√£o (pol√≠tica same-origin)
from flask_cors import CORS

# SCHEMAS - Nossos schemas Pydantic customizados
# Importa valida√ß√µes que criamos em schemas.py
from schemas import TarefaCreateSchema, TarefaUpdateSchema

# ===================================================================================
# üåç INST√ÇNCIAS GLOBAIS (Padr√£o Application Factory)
# ===================================================================================

# Por que criar aqui e n√£o dentro de create_app()?
# Resposta: Para poder importar em outros arquivos (ex: models.py, tests/)
# As extens√µes s√£o inicializadas depois com .init_app(app)

db = SQLAlchemy()        # ORM - comunica com banco de dados
bcrypt = Bcrypt()        # Hashing de senhas
jwt = JWTManager()       # Gerenciamento de tokens JWT
migrate = Migrate()      # Migra√ß√µes do banco


# ===================================================================================
# üóÑÔ∏è MODELOS DO BANCO DE DADOS (ORM)
# ===================================================================================

# O QUE √â ORM?
# Object-Relational Mapping = mapeia classes Python ‚Üí tabelas SQL
# Benef√≠cios:
# - Escreve Python em vez de SQL
# - Banco port√°vel (muda PostgreSQL ‚Üí SQLite mudando s√≥ config)
# - Migra√ß√µes autom√°ticas
# - Type safety


class Usuario(db.Model):
    """
    Modelo de Usu√°rio - representa tabela 'usuario' no banco.
    
    Relacionamento: 1 usu√°rio ‚Üí N tarefas (one-to-many)
    Cascade: ao deletar usu√°rio, deleta suas tarefas automaticamente
    """
    
    # PRIMARY KEY - identificador √∫nico, auto-incremento
    # Ex: primeiro usu√°rio id=1, segundo id=2, etc
    id = db.Column(db.Integer, primary_key=True)
    
    # EMAIL - √∫nico (n√£o permite duplicados), obrigat√≥rio
    # String(120) = VARCHAR(120) em SQL
    email = db.Column(db.String(120), unique=True, nullable=False)
    
    # SENHA - hash bcrypt (200 chars), obrigat√≥rio
    # NUNCA armazene senha em texto plano!
    # Exemplo hash: "$2b$12$NaXz8Gh5..." (60 chars, mas deixamos 200 para seguran√ßa)
    senha = db.Column(db.String(200), nullable=False)
    
    # RELACIONAMENTO - Permite acessar usuario.tarefas
    # backref='usuario' - Permite acessar tarefa.usuario
    # lazy=True - Carrega tarefas s√≥ quando acessar usuario.tarefas (n√£o automaticamente)
    # cascade='all, delete-orphan' - Ao deletar usuario, deleta suas tarefas
    tarefas = db.relationship(
        'Tarefa',                   # Modelo relacionado
        backref='usuario',          # Tarefa.usuario acessa o usu√°rio dono
        lazy=True,                  # Lazy loading (performance)
        cascade='all, delete-orphan'  # Dele√ß√£o em cascata
    )


class Tarefa(db.Model):
    """
    Modelo de Tarefa - representa tabela 'tarefa' no banco.
    
    Relacionamento: N tarefas ‚Üí 1 usu√°rio (many-to-one)
    Cada tarefa DEVE ter um dono (user_id obrigat√≥rio)
    """
    
    # PRIMARY KEY
    id = db.Column(db.Integer, primary_key=True)
    
    # DESCRI√á√ÉO - texto da tarefa, obrigat√≥rio
    # Ex: "Estudar algoritmos de ordena√ß√£o"
    descricao = db.Column(db.String(200), nullable=False)
    
    # CONCLU√çDA - Boolean, padr√£o False
    # Permite marcar tarefa como feita
    concluida = db.Column(db.Boolean, default=False)
    
    # PRIORIDADE - enum-like (baixa, media, alta)
    # Default = 'baixa' (se n√£o informar, assume baixa)
    prioridade = db.Column(db.String(50), nullable=False, default='baixa')
    
    # FOREIGN KEY - Chave estrangeira para tabela Usuario
    # db.ForeignKey('usuario.id') = referencia coluna "id" da tabela "usuario"
    # nullable=False = toda tarefa DEVE ter um dono
    # Isso cria relacionamento N:1 (muitas tarefas ‚Üí 1 usu√°rio)
    user_id = db.Column(db.Integer, db.ForeignKey('usuario.id'), nullable=False)



# ===================================================================================
# üè≠ APPLICATION FACTORY (Padr√£o de Projeto)
# ===================================================================================

def create_app(config_class='config.DevelopmentConfig'):
    """
    Factory Function - Cria e configura inst√¢ncia da aplica√ß√£o Flask.
    
    POR QUE USAR FACTORY AO INV√âS DE app = Flask(__name__) NO TOPO?
    
    ‚úÖ Vantagens do Factory Pattern:
    1. M√∫ltiplos ambientes: Development, Testing, Production
    2. Testes isolados: cada teste cria app pr√≥pria
    3. Evita circular imports (models importa db, app importa models)
    4. Facilita CI/CD: muda config via vari√°vel de ambiente
    
    Analogia: F√°brica de carros
    - create_app('SportConfig') ‚Üí Carro esportivo
    - create_app('TruckConfig') ‚Üí Caminh√£o
    - Mesma f√°brica, produtos diferentes
    
    Args:
        config_class (str): Classe de configura√ß√£o a usar
            - 'config.DevelopmentConfig': SQLite, Debug ON
            - 'config.ProductionConfig': PostgreSQL, Debug OFF
            - 'config.TestingConfig': SQLite in-memory, Testing ON
    
    Returns:
        Flask: Aplica√ß√£o configurada e pronta para rodar
    """
    
    # ==================
    # 1. CRIAR APP
    # ==================
    app = Flask(__name__)  # __name__ = nome do m√≥dulo (usado para localizar templates/static)
    
    # ==================
    # 2. CARREGAR CONFIGURA√á√ÉO
    # ==================
    # config.from_object() carrega vari√°veis da classe de config
    # Ex: DevelopmentConfig tem SQLALCHEMY_DATABASE_URI = "sqlite:///..."
    app.config.from_object(config_class)

    # ==================
    # 3. INICIALIZAR EXTENS√ïES
    # ==================
    # Por que .init_app() e n√£o passar app no construtor?
    # Resposta: Permite usar mesma inst√¢ncia (db, bcrypt) em m√∫ltiplas apps
    # √ötil para testes (cada teste cria app separada)
    
    db.init_app(app)          # ORM - conecta ao banco configurado
    bcrypt.init_app(app)      # Hashing - usa SECRET_KEY do config
    jwt.init_app(app)         # JWT - usa JWT_SECRET_KEY do config
    migrate.init_app(app, db) # Migrations - conecta Flask-Migrate ao banco
    
    # ==================
    # 4. CORS - CRUCIAL PARA FRONTEND
    # ==================
    # Por que CORS √© necess√°rio?
    # Problema: Navegadores bloqueiam requisi√ß√µes cross-origin (seguran√ßa)
    # Cen√°rio: frontend em localhost:8000 quer acessar API em localhost:5000
    # Sem CORS: Navegador bloqueia ‚Üí erro "CORS policy"
    # Com CORS: Servidor diz "pode acessar" ‚Üí requisi√ß√£o passa
    #
    # Headers que CORS adiciona:
    # Access-Control-Allow-Origin: *  (permite qualquer origem)
    # Access-Control-Allow-Methods: GET, POST, PUT, DELETE
    # Access-Control-Allow-Headers: Content-Type, Authorization
    CORS(app)

    # ==================
    # 5. CONFIGURAR SWAGGER (Flask-RESTX)
    # ==================
    
    # Authorizations - Define esquema de autentica√ß√£o JWT para Swagger UI
    # Permite testar endpoints protegidos diretamente no /docs
    authorizations = {
        'jwt': {
            'type': 'apiKey',           # Tipo: chave de API
            'in': 'header',             # Enviado no header HTTP
            'name': 'Authorization',    # Nome do header
            'description': "Digite 'Bearer ' antes do seu token. Ex: 'Bearer ey...'"
        }
    }

    # API principal - Configura√ß√£o do Swagger
    api = Api(
        app,
        version='1.0',                  # Vers√£o da API
        title='API de Tarefas',         # T√≠tulo no Swagger
        description='Uma API completa para gerenciamento de tarefas com ciclo DevOps.',
        authorizations=authorizations,  # Passa config JWT
        doc='/docs'                     # URL da documenta√ß√£o: http://localhost:5000/docs
    )

    # ===================================================================================
    # Namespaces e Modelos de Dados para o Swagger
    # ===================================================================================
    ns_auth = api.namespace('auth', description='Opera√ß√µes de Autentica√ß√£o')
    ns_tarefas = api.namespace(
        'tarefas', description='Opera√ß√µes relacionadas a tarefas',
        decorators=[jwt_required()]
    )

    modelo_registro = ns_auth.model('Registro', {
        'email': fields.String(required=True, description='Email para novo usu√°rio'),
        'senha': fields.String(required=True, description='Senha para o novo usu√°rio')
    })

    modelo_login = ns_auth.model('Login', {
        'email': fields.String(required=True, description='Email do usu√°rio'),
        'senha': fields.String(required=True, description='Senha do usu√°rio')
    })

    modelo_tarefa_output = ns_tarefas.model('TarefaOutput', {
        'id': fields.Integer(readOnly=True),
        'descricao': fields.String,
        'concluida': fields.Boolean,
        'prioridade': fields.String
    })

    modelo_tarefa_input = ns_tarefas.model('TarefaInput', {
        'descricao': fields.String(required=True, min_length=3),
        'prioridade': fields.String(default='baixa', enum=['baixa', 'media', 'alta'])
    })

    # ===================================================================================
    # Rotas da API
    # ===================================================================================
    @ns_auth.route('/register')
    class RegistroResource(Resource):
        @ns_auth.expect(modelo_registro)
        @ns_auth.response(201, 'Usu√°rio criado com sucesso!')
        @ns_auth.response(409, 'Este email j√° est√° em uso')
        def post(self):
            """Registra um novo usu√°rio."""
            dados = request.get_json()
            email = dados.get('email')
            senha = dados.get('senha')

            if Usuario.query.filter_by(email=email).first():
                return {'erro': 'Este email j√° est√° em uso'}, 409

            senha_hash = bcrypt.generate_password_hash(senha).decode('utf-8')
            novo_usuario = Usuario(email=email, senha=senha_hash)
            db.session.add(novo_usuario)
            db.session.commit()
            return {'mensagem': 'Usu√°rio criado com sucesso!'}, 201

    @ns_auth.route('/login')
    class LoginResource(Resource):
        @ns_auth.expect(modelo_login)
        def post(self):
            """Autentica um usu√°rio e retorna um token JWT."""
            dados = request.get_json()
            email = dados.get('email')
            senha = dados.get('senha')
            usuario = Usuario.query.filter_by(email=email).first()

            if not usuario or not bcrypt.check_password_hash(usuario.senha, senha):
                return {'erro': 'Credenciais inv√°lidas'}, 401

            access_token = create_access_token(identity=email)
            return {'access_token': access_token}

    # >>> corrigido: sem a barra final, rota ser√° /tarefas (sem redirecionamento 308)
    @ns_tarefas.route('')
    @ns_tarefas.doc(security='jwt')
    class ListaDeTarefasResource(Resource):
        @ns_tarefas.marshal_list_with(modelo_tarefa_output)
        def get(self):
            """Lista todas as tarefas do usu√°rio logado"""
            # Obt√©m o email do usu√°rio a partir do token JWT
            email_usuario = get_jwt_identity()
            usuario = Usuario.query.filter_by(email=email_usuario).first()
            
            if not usuario:
                return {'erro': 'Usu√°rio n√£o encontrado'}, 404
            
            # Retorna apenas as tarefas do usu√°rio logado
            return Tarefa.query.filter_by(user_id=usuario.id).all()

        @ns_tarefas.expect(modelo_tarefa_input)
        @ns_tarefas.marshal_with(modelo_tarefa_output, code=201)
        def post(self):
            """Cria uma nova tarefa para o usu√°rio logado"""
            dados = api.payload
            try:
                tarefa_validada = TarefaCreateSchema(**dados)
            except ValidationError as e:
                return {"erros": e.errors()}, 400

            # Obt√©m o ID do usu√°rio logado
            email_usuario = get_jwt_identity()
            usuario = Usuario.query.filter_by(email=email_usuario).first()
            
            if not usuario:
                return {'erro': 'Usu√°rio n√£o encontrado'}, 404

            # Cria a tarefa associada ao usu√°rio
            nova_tarefa = Tarefa(**tarefa_validada.model_dump(), user_id=usuario.id)
            db.session.add(nova_tarefa)
            db.session.commit()
            return nova_tarefa, 201

    @ns_tarefas.route('/<int:id>')
    @ns_tarefas.doc(security='jwt', params={'id': 'O ID da Tarefa'})
    class TarefaResource(Resource):
        @ns_tarefas.marshal_with(modelo_tarefa_output)
        def get(self, id):
            """Busca uma tarefa pelo seu ID."""
            return Tarefa.query.get_or_404(id)

        @ns_tarefas.expect(modelo_tarefa_input)
        @ns_tarefas.marshal_with(modelo_tarefa_output)
        def put(self, id):
            """Atualiza uma tarefa existente."""
            tarefa = Tarefa.query.get_or_404(id)
            dados = api.payload
            try:
                dados_validados = TarefaUpdateSchema(**dados).model_dump(exclude_unset=True)
            except ValidationError as e:
                return {"erros": e.errors()}, 400

            for key, value in dados_validados.items():
                setattr(tarefa, key, value)

            db.session.commit()
            return tarefa

        @ns_tarefas.response(204, 'Tarefa deletada com sucesso')
        def delete(self, id):
            """Deleta uma tarefa."""
            tarefa = Tarefa.query.get_or_404(id)
            db.session.delete(tarefa)
            db.session.commit()
            return '', 204

    # üóÉÔ∏è INICIALIZA√á√ÉO DAS TABELAS NO BANCO
    # Cria automaticamente as tabelas quando app inicia
    # Essential para PostgreSQL em Container Apps!
    with app.app_context():
        try:
            print("üîÑ Tentando conectar no banco de dados...")
            db.create_all()
            print("‚úÖ Tabelas criadas com sucesso!")
        except Exception as e:
            print(f"‚ùå Erro ao criar tabelas: {e}")
            print("‚ö†Ô∏è  App vai iniciar mesmo assim - tabelas ser√£o criadas na primeira requisi√ß√£o")
            # N√£o falha a aplica√ß√£o, s√≥ loga o erro
    
    return app

# ===================================================================================
# üåç INSTANCIAR APP PARA USO DIRETO
# ===================================================================================
# Cria inst√¢ncia padr√£o da aplica√ß√£o para uso fora do factory pattern
app = create_app()

@app.route('/health')
def health_check():
    """Endpoint de verifica√ß√£o de sa√∫de da aplica√ß√£o - n√£o depende do banco"""
    return {'status': 'healthy', 'message': 'API est√° funcionando'}, 200

@app.route('/health/db')  
def health_check_db():
    """Endpoint de verifica√ß√£o de sa√∫de com teste de banco"""
    try:
        # Testa conex√£o com banco
        with app.app_context():
            db.engine.execute('SELECT 1')
        return {'status': 'healthy', 'database': 'connected'}, 200
    except Exception as e:
        return {'status': 'unhealthy', 'database': 'disconnected', 'error': str(e)}, 503

@app.route('/')
def index():
    return {'message': 'API funcionando', 'docs': '/docs'}, 200

if __name__ == '__main__':
    app.run(debug=True)
